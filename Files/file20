# ðŸ§ª NeuUITest â€“ Beispielprojekt fÃ¼r MVVM in WPF

**NeuUITest** ist eine moderne WPF-Anwendung zur AusfÃ¼hrung und Visualisierung von .NET-Unit-Tests.  
Gleichzeitig dient dieses Projekt als **praxisnahes Beispiel**, wie man die **MVVM-Architektur (Modelâ€“Viewâ€“ViewModel)** sauber und effektiv in WPF-Anwendungen implementiert.

---

## ðŸŽ¯ Ziel dieses Projekts

âœ… Zeigt die korrekte Trennung von Logik und UI mit MVVM  
âœ… UnterstÃ¼tzt das asynchrone AusfÃ¼hren von Unit-Tests  
âœ… Visualisiert **Test-Ausgaben und Ergebnisse live**

---

## â“ Was ist MVVM?

### MVVM = **Model â€“ View â€“ ViewModel**

| Ebene         | Aufgabe                                                                 |
|---------------|-------------------------------------------------------------------------|
| **Model**     | Stellt Datenstrukturen & Anwendungslogik bereit                         |
| **View**      | PrÃ¤sentationsebene (XAML), bindet an ViewModel, keine Logik             |
| **ViewModel** | Vermittelt zwischen View und Model, enthÃ¤lt Befehle und UI-ZustÃ¤nde     |

---

### Warum MVVM?

- âœ… Trennung von UI und Logik
- âœ… Einfach zu testen und zu warten
- âœ… UnterstÃ¼tzt Data Binding und Commands
- âœ… Keine Logik im Code-Behind notwendig
- âœ… Erleichtert Teamarbeit (UI-Designer & Entwickler getrennt)

---

## ðŸ—‚ï¸ Projektstruktur & Bedeutung der Ordner

Das Projekt ist strikt nach MVVM-Prinzipien strukturiert:

---

### `Helpers/` (Hilfsklassen)

Dieser Ordner enthÃ¤lt allgemeine Hilfsklassen, die mehrfach in ViewModels verwendet werden â€“ insbesondere fÃ¼r MVVM-typische Infrastruktur.

- **`RelayCommand.cs`**  
  Diese Klasse implementiert das `ICommand`-Interface und ermÃ¶glicht es, Methoden aus dem ViewModel an die BenutzeroberflÃ¤che zu binden.  
  Sie unterstÃ¼tzt sowohl **synchron** als auch **asynchron** ausgefÃ¼hrte Befehle und ersetzt klassische Event-Handler in der UI.

ðŸ” **Warum ist das wichtig?**  
Im MVVM kommuniziert die UI nicht direkt mit dem Code, sondern Ã¼ber **Commands**. `RelayCommand` bietet eine flexible MÃ¶glichkeit, beliebige Aktionen an SchaltflÃ¤chen, MenÃ¼punkte usw. zu binden.

ðŸ§  **Nutzen:** Trennung von UI und Logik durch Commands statt Event-Handler.

---

### `Kern/` (Model)

Hier liegt die GeschÃ¤ftslogik und Datenstruktur.

- **`TestResult.cs`**  
  Modell fÃ¼r ein Testergebnis inkl. Statusfarbe fÃ¼r UI.

- **`TestRunner.cs`**  
  FÃ¼hrt `testhost.console.exe` aus, liest und parst die Ausgabe asynchron.

- **`ProgramInfo.cs`**  
  EnthÃ¤lt Metadaten wie App-Name, Version und Autor.

ðŸ§  **Nutzen:** Reine Logik- und Datenklassen â€“ vÃ¶llig unabhÃ¤ngig von UI. Ideal testbar und wiederverwendbar.

---

### `Services/` (Service-Schicht)

Dient zur Abstraktion von externen VorgÃ¤ngen oder UI-nahem Verhalten.

- **Interfaces:**  
  - `ITestExecutionService.cs`: Abstraktion der Testlogik  
  - `IWindowService.cs`: Zeigt Fenster (z.â€¯B. About-Dialog)

- **Implementierungen:**  
  - `TestExecutionService.cs`: Nutzt `TestRunner`, um Tests auszufÃ¼hren  
  - `WindowService.cs`: Ã–ffnet das About-Fenster

ðŸ§  **Nutzen:** ViewModels bleiben frei von direkter UI-Interaktion.

---

### `UI/` (View)

Dieser Ordner enthÃ¤lt die **grafischen BenutzeroberflÃ¤chen** der Anwendung â€“ vollstÃ¤ndig in **XAML** definiert.

ðŸ’¡ Die Views sind Ã¼ber **DataBindings** mit den ViewModels verbunden. Die Steuerung erfolgt durch Properties und Commands aus dem ViewModel.  
âš ï¸ **Wichtig:** In einer sauberen MVVM-Architektur gehÃ¶rt keine Logik in den Code-Behind (`.xaml.cs`) â€“ alles wird Ã¼ber **Bindings** gelÃ¶st.

#### Enthaltene Views:

- **`MainWindow.xaml`**  
  Hauptfenster der Anwendung. Beinhaltet die Steuerung fÃ¼r das Laden einer DLL, das Starten von Tests, Konsolenausgabe und Testergebnis-Zusammenfassung.

- **`AboutWindow.xaml`**  
  Zeigt App-Informationen wie Name, Version und Autor â€“ gebunden an passendes ViewModel (`MainAboutWindow`).

- **`TestSummaryControl.xaml`**  
  Wiederverwendbare `UserControl`, die den Teststatus grafisch zusammenfasst (Bestanden / Fehlgeschlagen / Gesamt).

---

### Umgang mit Code-Behind (`.xaml.cs`)

Im MVVM sollte die Logik **mÃ¶glichst** im ViewModel bleiben.  
ðŸ”“ Code-Behind ist **nicht grundsÃ¤tzlich verboten**, aber:

âœ… Verwende Code-Behind nur fÃ¼r:

- `InitializeComponent()`
- UI-spezifische Visuals (z.â€¯B. Animationen, Fokus setzen)
- Fenstersteuerung (`ShowDialog()`, `Close()`, `DialogResult`)
- Ereignisse, die **keine Logik oder Datenmanipulation** enthalten

ðŸš« Vermeide in Code-Behind:

- GeschÃ¤ftslogik
- Zugriffe auf Models
- direkte Button-Click-Handler

ðŸ§  **Nutzen:**
- Die Views zeigen **ausschlieÃŸlich** Daten an, die vom ViewModel Ã¼ber Bindings bereitgestellt werden.
- Sie enthalten **keine Logik**, was die Wartbarkeit, Testbarkeit und Wiederverwendbarkeit verbessert.
- Designer:innen kÃ¶nnen die Views gestalten, ohne sich mit Logik befassen zu mÃ¼ssen.
- Die UI soll **nur anzeigen**, was das ViewModel bereitstellt. Das hÃ¤lt die UI einfach, testbar und vom Verhalten getrennt.

---

### `ViewModels/` (ViewModel)

Verbindet View â‡„ Model, verarbeitet Benutzerinteraktionen und enthÃ¤lt UI-ZustÃ¤nde.

#### ðŸ”¹ Basisklasse:

- **`MainWindowBase.cs`**  
  Implementiert `INotifyPropertyChanged`

#### ðŸ”¹ Haupt-ViewModel:

- **`MainMainWindow.cs`**  
  Komponiert alle Sub-ViewModels

#### ðŸ”¹ Sub-ViewModels:

- `RunTestsMainWindow.cs` â†’ FÃ¼hrt Tests aus, aktualisiert UI  
- `BrowseDllMainWindow.cs` â†’ Ã–ffnet Datei-Dialog fÃ¼r DLL  
- `MainTestSummaryControl.cs` â†’ ZÃ¤hlt Passed/Failed/Total  
- `AboutAboutWindow.cs` â†’ Steuert das About-Fenster  
- `MainAboutWindow.cs` â†’ Stellt AppInfo bereit

ðŸ§  **Nutzen:**  
Alle ViewModels sind lose gekoppelt, testbar, wiederverwendbar und UI-unabhÃ¤ngig.

---

## ðŸ§© Projekt erweitern im MVVM-Stil â€“ am Beispiel "About"

Wenn du eine neue FunktionalitÃ¤t (z.â€¯B. ein neues Fenster oder eine neue UI-Komponente) hinzufÃ¼gen mÃ¶chtest, folge dieser Struktur:

### âœ… Beispiel: "About"-Fenster (App-Informationen anzeigen)

1. **ðŸ§± Model anlegen (optional)**  
   - Falls nÃ¶tig, erstelle ein neues Datenmodell unter `Kern/` (z.â€¯B. `ProgramInfo.cs`), um relevante Daten wie Name, Version, Autor etc. bereitzustellen.  
   - Modelle enthalten **nur Daten**, keine Logik.

2. **ðŸ§  ViewModel erstellen**  
   - Lege ein neues ViewModel unter `ViewModels/` an (z.â€¯B. `MainAboutWindow.cs`).
   - Dieses ViewModel lÃ¤dt die Daten (z.â€¯B. von `ProgramInfo`) und stellt sie als `public string`-Properties fÃ¼r das Binding bereit.
   - Falls Interaktionen nÃ¶tig sind (z.â€¯B. ein Button in der View), erstelle eine `RelayCommand`-Instanz.

3. **ðŸªŸ View (XAML) erstellen**  
   - In `UI/` legst du eine neue `Window`- oder `UserControl`-Datei an (z.â€¯B. `AboutWindow.xaml`).
   - Definiere das Layout mit `TextBlock`, `StackPanel`, etc.
   - Weise das passende ViewModel als `DataContext` zu (manuell im Code-Behind oder via Binding).

4. **ðŸ”§ Code-Behind minimal halten**  
   - Nur das nÃ¶tigste wie `InitializeComponent()` und ggf. `ShowDialog()` (z.â€¯B. Ã¼ber einen Service) gehÃ¶rt in die `.xaml.cs`-Datei.  
   - **Keine Datenlogik oder UI-Logik dort!**

5. **ðŸ› ï¸ Service zur Anzeige (optional)**  
   - Um UI-Aktionen vom ViewModel auszufÃ¼hren (z.â€¯B. Fenster Ã¶ffnen), implementiere ein Interface wie `IWindowService` im Ordner `Kern/Services`.  
   - Die konkrete Implementierung (`WindowService`) kÃ¼mmert sich dann darum, das Fenster zu Ã¶ffnen.

6. **ðŸ” Integration im Haupt-ViewModel**  
   - In `MainMainWindow.cs` oder dem zustÃ¤ndigen ViewModel registrierst du dein neues Sub-ViewModel (z.â€¯B. `AboutViewModel = new AboutAboutWindow(...)`)  
   - Die UI (z.â€¯B. ein Button) bindet sich an einen `ShowAboutCommand` im ViewModel.

---

### â™»ï¸ Wiederverwendung fÃ¼r andere Funktionen

Folge fÃ¼r **jede neue Funktion oder Ansicht** demselben Schema:

> **Model â†’ ViewModel â†’ View â†’ ggf. Service â†’ Command-Bindings**

So bleibt die Architektur konsistent, testbar und leicht erweiterbar.

âœ… **Tipp:**  
Teile Logik von ViewModels in Services aus, wenn sie wiederverwendbar werden oder nicht direkt zur Darstellung gehÃ¶ren.