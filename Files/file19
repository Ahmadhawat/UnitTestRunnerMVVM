### `Helpers/` (Hilfsklassen)

Dieser Ordner enthÃ¤lt allgemeine Hilfsklassen, die in mehreren ViewModels wiederverwendet werden â€“ insbesondere fÃ¼r MVVM-typische Infrastruktur.

- **`RelayCommand.cs`**  
  Diese Klasse implementiert das `ICommand`-Interface und ermÃ¶glicht es, Methoden aus dem ViewModel an die BenutzeroberflÃ¤che zu binden.  
  Sie unterstÃ¼tzt sowohl **synchrone** als auch **asynchrone** AusfÃ¼hrungen und ersetzt klassische Event-Handler in der UI.

ğŸ“Œ **Warum ist das wichtig?**  
In MVVM kommuniziert die UI nicht direkt mit dem Code, sondern Ã¼ber `Commands`. `RelayCommand` bietet eine flexible MÃ¶glichkeit, beliebige Aktionen an SchaltflÃ¤chen, MenÃ¼punkte usw. zu binden â€“ **ohne Code-Behind**.

ğŸ“Œ **Beispielhafte Verwendung**:
```csharp
public ICommand RunTestsCommand { get; }
RunTestsCommand = new RelayCommand(async () => await RunTestsAsync(), () => !IsTestRunning);





### `UI/` (View)

Dieser Ordner enthÃ¤lt die **BenutzeroberflÃ¤che der Anwendung**, definiert ausschlieÃŸlich in **XAML**.

ğŸ”’ **Wichtig:** In einer sauberen MVVM-Architektur gehÃ¶rt **keine Logik in den Code-Behind** (`.xaml.cs`) â€“ alles wird Ã¼ber **Data Bindings** und **Commands** an das ViewModel angebunden.

---

#### Enthaltene Views:

- **`MainWindow.xaml`**  
  Hauptfenster der Anwendung. EnthÃ¤lt die UI-Elemente zur:
  - Auswahl einer Test-DLL
  - AusfÃ¼hrung der Tests
  - Anzeige der Terminalausgabe (ConsoleOutput)
  - Darstellung der Testergebnisse (SummaryResults)

- **`AboutWindow.xaml`**  
  Ein modales Dialogfenster, das Informationen wie App-Name, Version und Autor anzeigt â€“ gebunden an `MainAboutWindow`.

- **`TestSummaryControl.xaml`**  
  Eine wiederverwendbare **UserControl**, die die Anzahl bestandener, fehlgeschlagener und aller Tests anzeigt â€“ eingebunden in `MainWindow.xaml`.

---

#### Umgang mit Code-Behind (`.xaml.cs`)

Im Sinne von MVVM soll der Code-Behind **nur fÃ¼r UI-technische Initialisierungen** wie `InitializeComponent()` verwendet werden.

âŒ **Keine Logik, keine Events, keine direkten Funktionsaufrufe** im Code-Behind!  
âœ… Stattdessen: Alles Ã¼ber das zugehÃ¶rige ViewModel binden (`DataContext`, `ICommand`, Properties).

---

ğŸ“Œ **Nutzen:**  
- Die Views zeigen **ausschlieÃŸlich** Daten an, die vom ViewModel Ã¼ber Bindings bereitgestellt werden.
- Sie enthalten **keine Logik**, was die Wartbarkeit, Testbarkeit und Wiederverwendbarkeit verbessert.
- Designer:innen kÃ¶nnen die Views gestalten, ohne sich mit Logik befassen zu mÃ¼ssen.




### `UI/` (View)

Dieser Ordner enthÃ¤lt die **grafische BenutzeroberflÃ¤che** der Anwendung â€“ vollstÃ¤ndig in **XAML** definiert.

ğŸ”— Die Views sind Ã¼ber **DataBindings** mit den ViewModels verbunden. Die Steuerung erfolgt durch Properties und Commands aus dem ViewModel.

---

#### Enthaltene Views:

- **`MainWindow.xaml`**  
  Hauptfenster der Anwendung. Beinhaltet die Steuerung fÃ¼r das Laden einer DLL, das Starten von Tests, Konsolenausgabe und Testergebnis-Zusammenfassung.

- **`AboutWindow.xaml`**  
  Zeigt App-Informationen wie Name, Version und Autor an â€“ gebunden an ein passendes ViewModel (`MainAboutWindow`).

- **`TestSummaryControl.xaml`**  
  Wiederverwendbare `UserControl`, die den Teststatus grafisch zusammenfasst (Bestanden / Fehlgeschlagen / Gesamt).

---

#### Umgang mit Code-Behind (`.xaml.cs`)

In MVVM sollte die Logik **mÃ¶glichst** im ViewModel bleiben.  
â¡ï¸ **Code-Behind ist nicht grundsÃ¤tzlich verboten**, aber:

âœ… Verwende Code-Behind nur fÃ¼r:  
- `InitializeComponent()`  
- UI-spezifische Visuals (z.â€¯B. Animationen, Fokus setzen)  
- Fenstersteuerung (`ShowDialog()`, `Close()`, `DialogResult`)  
- Ereignisse, die **keine Logik oder Datenmanipulation** enthalten

âŒ Vermeide im Code-Behind:
- GeschÃ¤ftslogik
- Zugriff auf Models
- direkte Button-Click-Handler

---

ğŸ“Œ **Fazit:**  
Die Views sollen **nur anzeigen**, was das ViewModel bereitstellt. Das hÃ¤lt die UI einfach, testbar und vom Verhalten getrennt. Der Code-Behind bleibt minimal und konzentriert sich nur auf rein visuelle Details.


---

## ğŸ§© Projekt erweitern im MVVM-Stil â€“ am Beispiel "About"

Wenn du eine neue FunktionalitÃ¤t (z.â€¯B. ein neues Fenster oder eine neue UI-Komponente) hinzufÃ¼gen mÃ¶chtest, folge dieser Struktur:

### Beispiel: "About"-Fenster (App-Informationen anzeigen)

1. **Model anlegen (optional)**
   - âœï¸ Falls nÃ¶tig, erstelle ein neues Datenmodell unter `Kern/` (z.â€¯B. `ProgramInfo.cs`), um relevante Daten wie Name, Version, Autor etc. bereitzustellen.
   - âœ… Modelle enthalten **nur Daten**, keine Logik.

2. **ViewModel erstellen**
   - ğŸ“ Lege ein neues ViewModel unter `ViewModels/` an (z.â€¯B. `MainAboutWindow.cs`).
   - Dieses ViewModel lÃ¤dt die Daten (z.â€¯B. von `ProgramInfo`) und stellt sie als `public string`-Properties fÃ¼r das Binding bereit.
   - Falls Interaktionen nÃ¶tig sind (z.â€¯B. ein Button in der View), erstelle eine `RelayCommand`-Instanz.

3. **View (XAML) erstellen**
   - ğŸ“ Im Ordner `UI/` legst du eine neue `Window`- oder `UserControl`-Datei an (z.â€¯B. `AboutWindow.xaml`).
   - Definiere das Layout mit `TextBlock`, `StackPanel`, etc.
   - Weise das passende ViewModel als `DataContext` zu (manuell im Code-Behind oder via Binding).

4. **Code-Behind minimal halten**
   - Nur das nÃ¶tigste wie `InitializeComponent()` und ggf. `ShowDialog()` (z.â€¯B. Ã¼ber einen Service) gehÃ¶rt in die `.xaml.cs`-Datei.
   - **Keine Datenlogik oder UI-Logik dort!**

5. **Service zur Anzeige (optional)**
   - Um UI-Aktionen vom ViewModel auszufÃ¼hren (z.â€¯B. Fenster Ã¶ffnen), implementiere ein Interface wie `IWindowService` im Ordner `Kern/Services`.
   - Die konkrete Implementierung (`WindowService`) kÃ¼mmert sich dann darum, das Fenster zu Ã¶ffnen.

6. **Integration im Haupt-ViewModel**
   - In `MainMainWindow.cs` oder dem zustÃ¤ndigen ViewModel registrierst du dein neues Sub-ViewModel (z.â€¯B. `AboutViewModel = new AboutAboutWindow(...)`)
   - Die UI (z.â€¯B. ein Button) bindet sich an einen `ShowAboutCommand` im ViewModel.

---

### ğŸ” Wiederverwendung fÃ¼r andere Funktionen

Folge fÃ¼r **jede neue Funktion oder Ansicht** demselben Schema:

> ğŸ”¹ Model â†’ ğŸ”¹ ViewModel â†’ ğŸ”¹ View â†’ ğŸ”¹ ggf. Service â†’ ğŸ”¹ Command-Bindings

So bleibt die Architektur konsistent, testbar und leicht erweiterbar.

---

âœ… **Tipp:**  
Teile Logik von ViewModels in Services aus, wenn sie wiederverwendet werden oder nicht direkt zur Darstellung gehÃ¶ren.